---
title: Mutation operators
description: Details of mutation operators provided with PIT
tags: mutators
keywords: mutation testing, mutation operator
layout: default
permalink: /quickstart/mutators/
---

# Overview

PIT currently provides some built-in mutators, of which most are activated by default. The default set can be overridden, and different operators selected, by passing the names of the required operators to the **mutators** parameter. 

Mutations are performed on the byte code generated by the compiler rather than on the source files. This approach has the advantage of being generally much faster and easier to incorporate into a build, but it can sometimes be difficult to simply describe how the mutation operators map to equivalent changes to a Java source file.

The operators are largely designed to be **stable** (i.e not be too easy to detect) and minimise the number of equivalent mutations that they generate. Those operators that do not meet these requirements are not enabled by default.

# Available mutators

We'll briefly describe the available mutators in the following sections. See the [test cases](#TEST_CASES) for
more detailed examples.

Here is the list of available mutators:

(*activated by default*)
- [Conditionals Boundary Mutator](#CONDITIONALS_BOUNDARY)
- [Increments Mutator](#INCREMENTS)
- [Invert Negatives Mutator](#INVERT_NEGS)
- [Math Mutator](#MATH)
- [Negate Conditionals Mutator](#NEGATE_CONDITIONALS)
- [Return Values Mutator](#RETURN_VALS)
- [Void Method Calls Mutator](#VOID_METHOD_CALLS)

(*deactivated by default*)
- [Constructor Calls Mutator](#CONSTRUCTOR_CALLS)
- [Inline Constant Mutator](#INLINE_CONSTS)
- [Non Void Method Calls Mutator](#NON_VOID_METHOD_CALLS)
- [Remove Conditionals Mutator](#REMOVE_CONDITIONALS)
- [Experimental Member Variable Mutator](#EXPERIMENTAL_MEMBER_VARIABLE)
- [Experimental Switch Mutator](#EXPERIMENTAL_SWITCH)

See the current [code](https://github.com/hcoles/pitest/blob/master/pitest/src/main/java/org/pitest/mutationtest/engine/gregor/config/Mutator.java) for current list (latest development version).

----

<a name="CONDITIONALS_BOUNDARY" id="CONDITIONALS_BOUNDARY"></a>

Conditionals Boundary Mutator (CONDITIONALS_BOUNDARY)
-----------------------------------------------------

**Active by default**

The conditionals boundary mutator replaces the relational operators `<, <=, >, >=` 

with their boundary counterpart as per the table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>&lt;</td>
            <td>&lt;=</td>
        </tr>
        <tr>
            <td>&lt;=</td>
            <td>&lt;</td>
        </tr>
        <tr>
            <td>&gt;</td>
            <td>&gt;=</td>
        </tr>
        <tr>
            <td>&gt;=</td>
            <td>&gt;</td>
        </tr>
    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
if (a &lt; b) {
  // do something
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
if (a &lt;= b) {
  // do something
}
</pre>

<a name="NEGATE_CONDITIONALS" id="NEGATE_CONDITIONALS"></a>

Negate Conditionals Mutator (NEGATE_CONDITIONALS)
-------------------------------------------------

**Active by default**

The negate conditionals mutator will mutate all conditionals found according
to the replacement table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>!=</td>
            <td>==</td>
        </tr>
        <tr>
            <td>&lt;=</td>
            <td>&gt;</td>
        </tr>
        <tr>
            <td>&gt;=</td>
            <td>&lt;</td>
        </tr>
        <tr>
            <td>&lt;</td>
            <td>&gt;=</td>
        </tr>
        <tr>
            <td>&gt;</td>
            <td>&lt;=</td>
        </tr>

    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
if (a == b) {
  // do something
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
if (a != b) {
  // do something
}
</pre>

This mutator overlaps to a degree with the conditionals boundary mutator, but is less **stable** i.e these
mutations are generally easier for a test suite to detect.


<a name="REMOVE_CONDITIONALS" id="REMOVE_CONDITIONALS"></a>

Remove Conditionals Mutator (REMOVE_CONDITIONALS)
-------------------------------------------------

The remove conditionals mutator will remove all conditionals statements such that the guarded statements always
execute

For example


<pre class="prettyprint lang-java">
if (a == b) {
  // do something
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
if (true) {
  // do something
}
</pre>

Although not currently enabled by default it is highly recommended that you enable it if you wish to ensure your test suite has full coverage of conditional statements.

As shown above the basic remove conditionals mutator ensures that the statements following the conditional always execute. It will also only mutate only equality checks (eg ==, !=).

Additional specialised versions of the mutator exist that will ensure the block never executes so

<pre class="prettyprint lang-java">
if (a == b) {
  // do something
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
if (false) {
  // do something
}
</pre>

If an else block is present it will always execute 

<pre class="prettyprint lang-java">
if (a == b) {
  // do something
} else {
  // do something else
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
if (false) {
  // do something
} else {
  // do something else
}
</pre>

Specialisations also exist that will mutate the bytecode instructions for order checks (eg <=, >).

The available specialisations are

* REMOVE_CONDITIONALS_EQ_IF
* REMOVE_CONDITIONALS_EQ_ELSE
* REMOVE_CONDITIONALS_ORD_IF
* REMOVE_CONDITIONALS_ORD_ELSE

The names reflect which branch will be forced to execute (the "if" or the "else") and the type of checks that will be mutated. 

The reason these are not enabled by default is that there is a large degree of overlap in the tests required to kill these mutations and those required to kill mutations from other default operators such as the conditional boundaries mutator.

<a name="MATH" id="MATH"></a>

Math Mutator (MATH)
-------------------

**Active by default**

The math mutator replaces binary arithmetic operations for either integer or 
floating-point arithmetic with another operation. The replacements will be 
selected according to the table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>+</td>
            <td>-</td>
        </tr>
        <tr>
            <td>-</td>
            <td>+</td>
        </tr>
        <tr>
            <td>*</td>
            <td>/</td>
        </tr>
        <tr>
            <td>/</td>
            <td>*</td>
        </tr>
        <tr>
            <td>%</td>
            <td>*</td>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>|</td>
        </tr>
        <tr>
            <td>|</td>
            <td>&amp;</td>
        </tr>
        <tr>
            <td>^</td>
            <td>&amp;</td>
        </tr>
        <tr>
            <td>&lt;&lt;</td>
            <td>&gt;&gt;</td>
        </tr>
        <tr>
            <td>&gt;&gt;</td>
            <td>&lt;&lt;</td>
        </tr>
        <tr>
            <td>&gt;&gt;&gt;</td>
            <td>&lt;&lt;</td>
        </tr>
    </tbody>
</table>


For example

<pre class="prettyprint lang-java">
int a = b + c;
</pre>

will be mutated to

<pre class="prettyprint lang-java">
int a = b - c;
</pre>

Keep in mind that the `+` operator on `String`s as in

<pre class="prettyprint lang-java">
String a = "foo" + "bar";
</pre>

is **not a mathematical operator** but a string concatenation and will be 
replaced by the compiler with something like

<pre class="prettyprint lang-java">
String a = new StringBuilder("foo").append("bar").toString();
</pre>


Please note that the compiler will also use binary arithmetic operations for
increments, decrements and assignment increments and decrements of non-local
variables (member variables) although a special `iinc` opcode for increments 
exists. This special opcode is restricted to local variables (also called stack
variables) and cannot be used for member variables. That means the math mutator
will also mutate

<pre class="prettyprint lang-java">
public class A {
  private int i;

  public void foo() {
    this.i++;
  }
}
</pre>

to

<pre class="prettyprint lang-java">
public class A {
  private int i;

  public void foo() {
    this.i = this.i - 1;
  }
}
</pre>

See the [Increments Mutator](#INCREMENTS) for details.

<a name="INCREMENTS" id="INCREMENTS"></a>

Increments Mutator (INCREMENTS)
-------------------------------

**Active by default**

The increments mutator will mutate increments, decrements and assignment
increments and decrements of local variables (stack variables). It will replace
increments with decrements and vice versa.

For example

<pre class="prettyprint lang-java">
public int method(int i) {
  i++;
  return i;
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public int method(int i) {
  i--;
  return i;
}
</pre>

Please note that the increments mutator will be applied to increments of 
**local variables only**. Increments and decrements of member variables will be
covered by the [Math Mutator](#MATH).

<a name="INVERT_NEGS" id="INVERT_NEGS"></a>

Invert Negatives Mutator (INVERT_NEGS)
--------------------------------------

**Active by default**

The invert negatives mutator inverts negation of integer and floating point 
numbers. For example

<pre class="prettyprint lang-java">
public float negate(final float i) {
  return -i;
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public float negate(final float i) {
  return i;
}
</pre>

<a name="INLINE_CONSTS" id="INLINE_CONSTS"></a>

Inline Constant Mutator (INLINE_CONSTS)
---------------------------------------

The inline constant mutator mutates inline constants. An inline constant is a
literal value assigned to a non-final variable, for example

<pre class="prettyprint lang-java">
public void foo() {
  int i = 3;
  // do something with i
}
</pre>

Depending on the type of the inline constant another mutation is used. The rules
are a little complex due to the different ways that apparently similar Java statements
are converted to byte code.


<table class="table">
    <thead>
        <tr>
            <th>Constant Type</th>
            <th>Mutation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td>
                replace the unmutated value <code>true</code> with <code>false</code> and
                replace the unmutated value <code>false</code> with <code>true</code>
            </td>
        </tr>
        <tr>
            <td><code>integer</code> <code>byte</code> <code>short</code></td>
            <td>
                replace the unmutated value <code>1</code> with <code>0</code>,
                <code>-1</code> with <code>1</code>, <code>5</code> with <code>-1</code>
                or otherwise increment the unmutated value by one. <a href="#fn1"><sup>1</sup></a> <a name="fnref1" id="fnref1"></a>
            </td>
        </tr>
        <tr>
            <td><code>long</code></td>
            <td>
                replace the unmutated value <code>1</code> with <code>0</code>, otherwise
                increment the unmutated value by one.
            </td>
        </tr>
        <tr>
            <td><code>float</code></td>
            <td>
                replace the unmutated values <code>1.0</code> and <code>2.0</code>
                with <code>0.0</code> and replace any other value with <code>1.0</code> <a href="#fn2"><sup>2</sup></a> <a name="fnref2" id="fnref2"></a>
            </td>
        </tr>
        <tr>
            <td><code>double</code></td>
            <td>
                replace the unmutated value <code>1.0</code> with <code>0.0</code>
                and replace any other value with <code>1.0</code> <a href="#fn3"><sup>3</sup></a> <a name="fnref3" id="fnref3"></a>
            </td>
        </tr>
    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
public int foo() {
  int i = 42;
  return i;
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public int foo() {
  int i = 43;
  return i;
}
</pre>

Please note that the compiler might optimize the use of final variables 
(regardless whether those are stack variables or member variables). For example
the following code

<pre class="prettyprint lang-java">
public class A {
  private static final int VAR = 13;
  
  public String foo() {
    final int i = 42;
    return "" + VAR + ":" + i;
  }
}
</pre>

will be changed/optimized by the compiler to

<pre class="prettyprint lang-java">
public class A {
  public String foo() {
    return "13:42";
  }
}
</pre>

In such situations the mutation engine can not mutate any variable.

<a name="RETURN_VALS" id="RETURN_VALS"></a>

Return Values Mutator (RETURN_VALS)
-----------------------------------

**Active by default**

The return values mutator mutates the return values of method calls. Depending
on the return type of the method another mutation is used.<a href="#fn4"><sup>4</sup></a> <a name="fnref4" id="fnref4"></a>

<table class="table">
    <thead>
        <tr>
            <th>Return Type</th>
            <th>Mutation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td>
                replace the unmutated return value <code>true</code> with <code>false</code> and
                replace the unmutated return value <code>false</code> with <code>true</code>
            </td>
        </tr>
        <tr>
            <td><code>int</code> <code>byte</code> <code>short</code></td>
            <td>
                if the unmutated return value is <code>0</code> return <code>1</code>, otherwise
                mutate to return value <code>0</code>
            </td>
        </tr>
        <tr>
            <td><code>long</code></td>
            <td>
                replace the unmutated return value <code>x</code> with the result of <code>x+1</code>
            </td>
        </tr>
        <tr>
            <td><code>float</code> <code>double</code></td>
            <td>
                replace the unmutated return value <code>x</code> with the result of
                <code>-(x+1.0)</code> if <code>x</code> is not <code>NAN</code> and
                replace <code>NAN</code> with <code>0</code>
            </td>
        </tr>
        <tr>
            <td><code>Object</code></td>
            <td>
                replace non-<code>null</code> return values with <code>null</code> and throw a
                <code>java.lang.RuntimeException</code> if the unmutated method
                would return <code>null</code>
            </td>
        </tr>
    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
public Object foo() {
  return new Object();
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public Object foo() {
  new Object();
  return null;
}
</pre>

<a name="VOID_METHOD_CALLS" id="VOID\_METHOD\_CALLS"></a>

Void Method Call Mutator (VOID_METHOD_CALLS)
--------------------------------------------

**Active by default**

The void method call mutator removes method calls to void methods. For example

<pre class="prettyprint lang-java">
public void someVoidMethod(int i) {
  // does something
}

public int foo() {
  int i = 5;
  doSomething(i);
  return i;
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public void someVoidMethod(int i) {
  // does something
}

public int foo() {
  int i = 5;
  return i;
}
</pre>

Please note that constructor calls are **not considered void method calls**.
See the [Constructor Call Mutator](#CONSTRUCTOR_CALL) for mutations of 
constructors or the [Non Void Method Call Mutator](#NON_VOID_METHOD_CALL) for
mutations of non void methods.


<a name="TRUE_RETURNS" id="TRUE_RETURNS"></a>

True returns Mutator (TRUE\_RETURNS)
-------------------------------------

Replaces primitive and boxed boolean return values with true.

Pitest will filter out equivalent mutations to methods that are already hard coded to return true.


<a name="FALSE_RETURNS" id="FALSE_RETURNS"></a>

False returns Mutator (FALSE\_RETURNS)
-------------------------------------

Replaces primitive and boxed boolean return values with false.

Pitest will filter out equivalent mutations to methods that are already hard coded to return false.

<a name="PRIMITIVE_RETURNS" id="PRIMITIVE_RETURNS"></a>

Primitive returns Mutator (PRIMITIVE\_RETURNS)
----------------------------------------------

Replaces int, short, long, char, float and double return values with 0.

Pitest will filter out equivalent mutations to methods that are already hard coded to return 0.

<a name="EMPTY_RETURNS" id="EMPTY_RETURNS"></a>

Empty returns Mutator (EMPTY\_RETURNS)
--------------------------------------

Replaces return values with an 'empty' value for that type as follows

* java.lang.String -> ""
* java.util.Optional -> Optional.empty()
* java.util.List -> Collections.emptyList()
* java.util.Collection -> Collections.emptyList()
* java.util.Set -> Collections.emptySet()
* java.lang.Integer -> 0
* java.lang.Short -> 0
* java.lang.Long -> 0
* java.lang.Character -> 0
* java.lang.Float -> 0
* java.lang.Double -> 0

Pitest will filter out equivalent mutations to methods that are already hard coded to return the empty value.

<a name="NULL_RETURNS" id="NULL_RETURNS"></a>

Null returns Mutator (NULL\_RETURNS)
--------------------------------------

Replaces return values with null. Methods that can be mutated by the EMPTY_RETURNS mutator or that are directly annotated with NotNull will not be mutated.

Pitest will filter out equivalent mutations to methods that are already hard coded to return null.

<a name="NON_VOID_METHOD_CALLS" id="NON_VOID_METHOD_CALLS"></a>

Non Void Method Call Mutator (NON\_VOID\_METHOD\_CALLS)
----------------------------------------------------

The non void method call mutator removes method calls to non void methods.
Their return value is replaced by the Java Default Value for that specific
type. See the table below.

Table: Java Default Values for Primitives and Reference Types


<table class="table">
    <thead>
        <tr>
            <th>Type</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
        </tr>
        <tr>
            <td><code>int</code> <code>byte</code> <code>short</code> <code>long</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>float</code> <code>double</code></td>
            <td><code>0.0</code></td>
        </tr>
        <tr>
            <td><code>char</code></td>
            <td><code>'\u0000'</code></td>
        </tr>
        <tr>
            <td><code>Object</code></td>
            <td><code>null</code></td>
        </tr>
    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
public int someNonVoidMethod() {
  return 5;
}

public void foo() {
  int i = someNonVoidMethod();
  // do more stuff with i
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public int someNonVoidMethod() {
  return 5;
}

public void foo() {
  int i = 0;
  // do more stuff with i
}
</pre>

and for method calls returning an object type the call

<pre class="prettyprint lang-java">
public Object someNonVoidMethod() {
  return new Object();
}

public void foo() {
  Object o = someNonVoidMethod();
  // do more stuff with o
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public Object someNonVoidMethod() {
  return new Object();
}

public void foo() {
  Object o = null;
  // do more stuff with o
}
</pre>

Please note that this mutation is fairly unstable for some types (especially Objects where
**`NullPointerException`s** are likely) and may also create equivalent mutations if
it replaces a method that already returns one of the default values without also having
a side effect.

This mutator does not affect void methods or constructor calls. See 
[Void Method Call Mutator](#VOID_METHOD_CALL) for mutations of void methods and
[Constructor Call Mutator](#CONSTRUCTOR_CALL) for mutations of constructors.

<a name="CONSTRUCTOR_CALLS" id="CONSTRUCTOR_CALLS"></a>

Constructor Call Mutator (CONSTRUCTOR_CALLS)
--------------------------------------------

The constructor call mutator replaces constructor calls with `null` values. For
example

<pre class="prettyprint lang-java">
public Object foo() {
  Object o = new Object();
  return o;
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
public Object foo() {
  Object o = null;
  return o;
}
</pre>

Please note that this mutation is fairly unstable and likely to cause **`NullPointerException`s** even
with weak test suites.

This mutator does not affect non constructor method calls. See [Void Method Call Mutator](#VOID_METHOD_CALL) for 
mutations of void methods and
[Non Void Method Call Mutator](#NON_VOID_METHOD_CALL) for mutations of non void
methods.

<a name="EXPERIMENTAL_MEMBER_VARIABLE" id="EXPERIMENTAL_MEMBER_VARIABLE"></a>
Experimental Member Variable Mutator (EXPERIMENTAL\_MEMBER\_VARIABLE)
-------------------------------------------------------------------

The experimental member variable mutator mutates classes by removing assignments
to member variables. The mutator can even remove assignments to final members.
The members will be initialized with their Java Default Value for the specific
type. See the table below.

Table: Java Default Values for Primitives and Reference Types

<table class="table">
    <thead>
        <tr>
            <th>Type</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <code>boolean</code>
            </td>
            <td>`false`</td>
        </tr>
        <tr>
            <td>
                <code>int</code>
                <code>short</code>
                <code>byte</code>
                <code>long</code>
            </td>
            <td>`0`</td>
        </tr>
        <tr>
            <td>
                <code>float</code>
                <code>double</code>
            </td>
            <td>`0.0`</td>
        </tr>
        <tr>
            <td>
                <code>char</code>
            </td>
            <td>`'\u0000'`</td>
        </tr>
        <tr>
            <td>
                <code>Object</code>
            </td>
            <td>`null`</td>
        </tr>
    </tbody>
</table>

For example

<pre class="prettyprint lang-java">
public class MutateMe {
    private final int x = 5;
    //...
}
</pre>

will be mutated to

<pre class="prettyprint lang-java">
  public class MutateMe {
    private final int x = 0;
    ...
  }
</pre>

**Please Note: This mutator is likely to create equivalent mutations** if a
member variable is **explicitly** initialized with the Java default value for 
the specific type of the member variable as in

<pre class="prettyprint lang-java">
public class EquivalentMutant {
    private int x = 0;
}
</pre>

<a name="EXPERIMENTAL_SWITCH" id="EXPERIMENTAL_SWITCH"></a>

Experimental Switch Mutator (EXPERIMENTAL_SWITCH)
-------------------------------------------------

The switch mutator finds the first label within a switch statement that differs from the default label. It mutates the switch statement by replacing the default label (wherever it is used) with this label. All the other labels are replaced by the default one.

*Thanks to Stefan Penndorf who contributed this documentation.*

<hr/>

1. <a name="fn1" id="fn1"></a> Integer numbers and booleans are actually represented in the same way be the JVM,
  it is therefore never safe if change a 0 to anything but a 1 or a 1 to anything but a 0.
  [↩](#fnref1)
2. <a name="fn2" id="fn2"></a> Floating point numbers are always changed to 1 rather than adding 1 to the original value
  as this would result in equivalent mutations. Adding 1 to a large floating point number
  doesn't necessarily change its value due to the imprecise way in which floats are represented.
  [↩](#fnref2)
3. <a name="fn3" id="fn3"></a> See note above which applies to both floats and doubles. [↩](#fnref3)
4. <a name="fn4" id="fn4"></a> The strategy used by this mutator was translated from code in the Jumble project
  [↩](#fnref4)
